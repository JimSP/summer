package com.github.jimsp.summer;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.MirroredTypeException;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;

import com.google.auto.service.AutoService;

@SupportedAnnotationTypes("com.github.jimsp.summer.Extension")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
@AutoService(Processor.class)
public class ExtensionProcessor extends AbstractProcessor {

	private final Set<MapperInfo> requiredMappers = new HashSet<>();
	private final Set<String> generatedSupportClasses = new HashSet<>();

	@Override
	public boolean process(final Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {

		final Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(Extension.class);

		if (annotatedElements.isEmpty()) {
			return true;
		}

		requiredMappers.clear();

		final Map<String, List<MethodInfo>> methodsByFinalReturnType = new HashMap<>();

		for (final Element element : annotatedElements) {
			if (element.getKind() == ElementKind.METHOD) {
				final ExecutableElement method = (ExecutableElement) element;
				final Extension extension = method.getAnnotation(Extension.class);

				final TypeMirror outputDomainType = getOutputDomainTypeMirror(extension);

				final String finalReturnType;
				if (outputDomainType != null && !isObjectType(outputDomainType)) {
					finalReturnType = outputDomainType.toString();
				} else {
					finalReturnType = method.getReturnType().toString();
				}

				final TypeElement enclosingClass = (TypeElement) method.getEnclosingElement();
				final PackageElement packageElement = processingEnv.getElementUtils().getPackageOf(enclosingClass);
				final String packageName = packageElement.getQualifiedName().toString();

				final String key = packageName + "###" + finalReturnType;

				methodsByFinalReturnType.computeIfAbsent(key, k -> new ArrayList<>())
						.add(new MethodInfo(method, enclosingClass));

				collectRequiredMappers(method, extension, packageName);
			}
		}

		generateSupportClasses();
		generateMappers();

		for (final Map.Entry<String, List<MethodInfo>> entry : methodsByFinalReturnType.entrySet()) {
			final String[] keyParts = entry.getKey().split("###");
			if (keyParts.length != 2)
				continue;

			final String packageName = keyParts[0];
			final String finalReturnType = keyParts[1];

			generateExtensionsForReturnType(packageName, finalReturnType, entry.getValue());
		}

		return true;
	}

	private void generateSupportClasses() {
		// Generate only once per compilation
		final String basePackage = "com.jimsp.jap";
		final String key = basePackage + ".InstanceProvider";

		if (generatedSupportClasses.contains(key)) {
			return;
		}
		generatedSupportClasses.add(key);

		generateInstanceProvider(basePackage);
		generateExtensionRegistry(basePackage);
	}

	private void generateInstanceProvider(final String packageName) {
		try {
			final String className = "InstanceProvider";
			final String fullyQualifiedName = packageName + "." + className;

			final Filer filer = processingEnv.getFiler();
			final JavaFileObject fileObject = filer.createSourceFile(fullyQualifiedName);

			try (final Writer writer = fileObject.openWriter()) {
				writer.write("package " + packageName + ";\n\n");

				writer.write("/**\n");
				writer.write(" * Provider interface for creating instances of classes\n");
				writer.write(" * Allows integration with any dependency injection container\n");
				writer.write(" * Generated by ExtensionProcessor\n");
				writer.write(" */\n");
				writer.write("public interface InstanceProvider {\n\n");

				writer.write("    /**\n");
				writer.write("     * Creates an instance of the specified class\n");
				writer.write("     * @param clazz the class to instantiate\n");
				writer.write("     * @param <T> the type of the class\n");
				writer.write("     * @return an instance of the class\n");
				writer.write("     * @throws RuntimeException if the instance cannot be created\n");
				writer.write("     */\n");
				writer.write("    <T> T getInstance(Class<T> clazz);\n");

				writer.write("}\n");
			}

		} catch (final IOException e) {
			processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
					"Failed to generate InstanceProvider: " + e.getMessage());
		}
	}

	private void generateExtensionRegistry(final String packageName) {
		try {
			final String className = "ExtensionRegistry";
			final String fullyQualifiedName = packageName + "." + className;

			final Filer filer = processingEnv.getFiler();
			final JavaFileObject fileObject = filer.createSourceFile(fullyQualifiedName);

			try (final Writer writer = fileObject.openWriter()) {
				writer.write("package " + packageName + ";\n\n");

				writer.write("/**\n");
				writer.write(" * Global registry for InstanceProvider\n");
				writer.write(" * Configure once at application startup\n");
				writer.write(" * Generated by ExtensionProcessor\n");
				writer.write(" */\n");
				writer.write("public final class ExtensionRegistry {\n\n");

				writer.write(
						"    private static volatile InstanceProvider instanceProvider = new DefaultInstanceProvider();\n\n");

				writer.write("    private ExtensionRegistry() {\n");
				writer.write("        throw new UnsupportedOperationException(\"Utility class\");\n");
				writer.write("    }\n\n");

				writer.write("    /**\n");
				writer.write("     * Sets the global InstanceProvider\n");
				writer.write("     * @param provider the provider to use\n");
				writer.write("     */\n");
				writer.write("    public static void setInstanceProvider(final InstanceProvider provider) {\n");
				writer.write("        if (provider == null) {\n");
				writer.write("            throw new IllegalArgumentException(\"InstanceProvider cannot be null\");\n");
				writer.write("        }\n");
				writer.write("        ExtensionRegistry.instanceProvider = provider;\n");
				writer.write("    }\n\n");

				writer.write("    /**\n");
				writer.write("     * Gets the current InstanceProvider\n");
				writer.write("     * @return the current provider\n");
				writer.write("     */\n");
				writer.write("    public static InstanceProvider getInstanceProvider() {\n");
				writer.write("        return instanceProvider;\n");
				writer.write("    }\n\n");

				writer.write("    /**\n");
				writer.write("     * Default implementation that tries to use no-arg constructor\n");
				writer.write("     */\n");
				writer.write("    private static class DefaultInstanceProvider implements InstanceProvider {\n");
				writer.write("        @Override\n");
				writer.write("        public <T> T getInstance(final Class<T> clazz) {\n");
				writer.write("            try {\n");
				writer.write("                return clazz.getDeclaredConstructor().newInstance();\n");
				writer.write("            } catch (final Exception e) {\n");
				writer.write(
						"                throw new RuntimeException(\"Failed to create instance of \" + clazz.getName() + \n");
				writer.write(
						"                    \". Configure ExtensionRegistry.setInstanceProvider() or ensure class has no-arg constructor.\", e);\n");
				writer.write("            }\n");
				writer.write("        }\n");
				writer.write("    }\n");

				writer.write("}\n");
			}

		} catch (final IOException e) {
			processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
					"Failed to generate ExtensionRegistry: " + e.getMessage());
		}
	}

	private boolean needsInstanceProvider(final TypeElement typeElement) {
		// Se for estático, não precisa
		final List<? extends Element> constructors = typeElement.getEnclosedElements().stream()
				.filter(e -> e.getKind() == ElementKind.CONSTRUCTOR).toList();

		// Se não tem construtor explícito, Java cria um padrão
		if (constructors.isEmpty()) {
			return false;
		}

		// Se tem construtor sem parâmetros, não precisa
		return constructors.stream().map(ExecutableElement.class::cast)
				.noneMatch(constructor -> constructor.getParameters().isEmpty());
	}

	private void collectRequiredMappers(final ExecutableElement method, final Extension extension,
			final String packageName) {
		final TypeMirror inputDomainType = getInputDomainTypeMirror(extension);
		final TypeMirror outputDomainType = getOutputDomainTypeMirror(extension);

		if (inputDomainType != null && !isObjectType(inputDomainType) && !method.getParameters().isEmpty()) {
			final String firstParamType = method.getParameters().get(0).asType().toString();
			final String inputDomainTypeString = inputDomainType.toString();

			if (!firstParamType.equals(inputDomainTypeString)) {
				requiredMappers
						.add(new MapperInfo(inputDomainTypeString, firstParamType, packageName, MapperType.INPUT));
			}
		}

		if (outputDomainType != null && !isObjectType(outputDomainType)) {
			final String originalReturnType = method.getReturnType().toString();
			final String outputDomainTypeString = outputDomainType.toString();

			if (!originalReturnType.equals(outputDomainTypeString)) {
				requiredMappers.add(
						new MapperInfo(originalReturnType, outputDomainTypeString, packageName, MapperType.OUTPUT));
			}
		}
	}

	private void generateMappers() {
		for (final MapperInfo mapperInfo : requiredMappers) {
			generateMapper(mapperInfo);
		}
	}

	private void generateMapper(final MapperInfo mapperInfo) {
		try {
			final String sourceSimpleName = getSimpleClassName(mapperInfo.sourceType);
			final String targetSimpleName = getSimpleClassName(mapperInfo.targetType);
			final String mapperClassName = sourceSimpleName + "To" + targetSimpleName + "Mapper";
			final String fullyQualifiedName = mapperInfo.packageName + "." + mapperClassName;

			final Filer filer = processingEnv.getFiler();
			final JavaFileObject fileObject = filer.createSourceFile(fullyQualifiedName);

			try (final Writer writer = fileObject.openWriter()) {
				writer.write("package " + mapperInfo.packageName + ";\n\n");
				writer.write("import org.mapstruct.Mapper;\n");
				writer.write("import org.mapstruct.factory.Mappers;\n\n");

				writer.write("/**\n");
				writer.write(" * Generated mapper for converting between " + sourceSimpleName + " and "
						+ targetSimpleName + "\n");
				writer.write(" * Generated by ExtensionProcessor\n");
				writer.write(" */\n");
				writer.write("@Mapper\n");
				writer.write("public interface " + mapperClassName + " {\n\n");

				writer.write(
						"    " + mapperClassName + " INSTANCE = Mappers.getMapper(" + mapperClassName + ".class);\n\n");

				if (mapperInfo.type == MapperType.INPUT) {
					writer.write("    /**\n");
					writer.write("     * Converts domain object to DTO\n");
					writer.write("     */\n");
					writer.write("    " + mapperInfo.targetType + " toDto(" + mapperInfo.sourceType + " source);\n\n");
				} else {
					writer.write("    /**\n");
					writer.write("     * Converts DTO to domain object\n");
					writer.write("     */\n");
					writer.write(
							"    " + mapperInfo.targetType + " toDomain(" + mapperInfo.sourceType + " source);\n\n");
				}

				writer.write("}\n");
			}

		} catch (final IOException e) {
			processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
					"Failed to generate mapper: " + e.getMessage());
		}
	}

	private TypeMirror getOutputDomainTypeMirror(final Extension extension) {
		try {
			extension.outputDomain();
			return null;
		} catch (final MirroredTypeException mte) {
			return mte.getTypeMirror();
		}
	}

	private TypeMirror getInputDomainTypeMirror(final Extension extension) {
		try {
			extension.inputDomain();
			return null;
		} catch (final MirroredTypeException mte) {
			return mte.getTypeMirror();
		}
	}

	private boolean isObjectType(final TypeMirror typeMirror) {
		if (typeMirror == null)
			return true;
		final String typeString = typeMirror.toString();
		return "java.lang.Object".equals(typeString) || "Object".equals(typeString);
	}

	private String getSimpleClassName(final String fullyQualifiedName) {
		if (fullyQualifiedName == null || fullyQualifiedName.trim().isEmpty()) {
			return "Unknown";
		}

		String cleanName = fullyQualifiedName;
		final int genericStart = cleanName.indexOf('<');
		if (genericStart > 0) {
			cleanName = cleanName.substring(0, genericStart);
		}

		final int lastDot = cleanName.lastIndexOf('.');
		return lastDot >= 0 ? cleanName.substring(lastDot + 1) : cleanName;
	}

	private void generateExtensionsForReturnType(final String packageName, final String finalReturnType,
			final List<MethodInfo> methods) {
		try {
			final String simpleReturnClassName = getSimpleClassName(finalReturnType);
			final String generatedClassName = simpleReturnClassName + "Extensions";
			final String fullyQualifiedName = packageName + "." + generatedClassName;

			final Filer filer = processingEnv.getFiler();
			final JavaFileObject fileObject = filer.createSourceFile(fullyQualifiedName);

			try (final Writer writer = fileObject.openWriter()) {
				writer.write("package " + packageName + ";\n\n");
				writer.write("import com.jimsp.jap.InstanceProvider;\n");
				writer.write("import com.jimsp.jap.ExtensionRegistry;\n\n");

				writer.write("/**\n");
				writer.write(" * Generated extensions for methods that return " + finalReturnType + "\n");
				writer.write(" * Groups all @Extension annotated methods with final return type "
						+ simpleReturnClassName + "\n");
				writer.write(" * Generated by ExtensionProcessor\n");
				writer.write(" */\n");
				writer.write("public final class " + generatedClassName + " {\n\n");

				writer.write("    private " + generatedClassName + "() {\n");
				writer.write("        throw new UnsupportedOperationException(\"Utility class\");\n");
				writer.write("    }\n\n");

				for (final MethodInfo methodInfo : methods) {
					generateExtensionMethod(writer, methodInfo, finalReturnType);
				}

				writer.write("}\n");
			}

		} catch (final IOException e) {
			processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
					"Failed to generate extensions: " + e.getMessage());
		}
	}

	private void generateExtensionMethod(final Writer writer, final MethodInfo methodInfo,
			final String expectedReturnType) throws IOException {
		final ExecutableElement method = methodInfo.method;
		final Extension extension = method.getAnnotation(Extension.class);

		final TypeMirror inputDomainType = getInputDomainTypeMirror(extension);
		final TypeMirror outputDomainType = getOutputDomainTypeMirror(extension);

		boolean hasInputConversion = false;
		boolean hasOutputConversion = false;

		if (inputDomainType != null && !isObjectType(inputDomainType) && !method.getParameters().isEmpty()) {
			final String firstParamType = method.getParameters().get(0).asType().toString();
			final String inputDomainTypeString = inputDomainType.toString();
			hasInputConversion = !firstParamType.equals(inputDomainTypeString);
		}

		if (outputDomainType != null && !isObjectType(outputDomainType)) {
			final String originalReturnType = method.getReturnType().toString();
			final String outputDomainTypeString = outputDomainType.toString();
			hasOutputConversion = !originalReturnType.equals(outputDomainTypeString);
		}

		if (hasInputConversion || hasOutputConversion) {
			generateMethodWithDomainConversions(writer, methodInfo, extension, inputDomainType, outputDomainType,
					expectedReturnType, hasInputConversion, hasOutputConversion);
		} else {
			generateSimpleExtensionMethod(writer, methodInfo, extension, expectedReturnType);
		}
	}

	private void generateMethodWithDomainConversions(final Writer writer, final MethodInfo methodInfo,
			final Extension extension, final TypeMirror inputDomainType, final TypeMirror outputDomainType,
			final String expectedReturnType, final boolean hasInputConversion, final boolean hasOutputConversion)
			throws IOException {

		final ExecutableElement method = methodInfo.method;
		final TypeElement enclosingClass = methodInfo.enclosingClass;

		final String methodName = buildMethodName(extension);
		final String originalReturnType = method.getReturnType().toString();

		final List<? extends VariableElement> parameters = method.getParameters();
		final boolean isStatic = method.getModifiers().contains(Modifier.STATIC);
		final boolean needsProvider = !isStatic && needsInstanceProvider(enclosingClass);

		writer.write("    /**\n");
		writer.write("     * Extension method: " + method.getSimpleName() + "\n");
		writer.write("     * Original method from: " + enclosingClass.getQualifiedName() + "\n");
		if (hasInputConversion) {
			writer.write("     * Input conversion: " + inputDomainType + " → " + parameters.get(0).asType() + "\n");
		}
		if (hasOutputConversion) {
			writer.write("     * Output conversion: " + originalReturnType + " → " + outputDomainType + "\n");
		}
		writer.write("     */\n");

		writer.write("    public static " + expectedReturnType + " " + methodName + "(");

		for (int i = 0; i < parameters.size(); i++) {
			final VariableElement param = parameters.get(i);
			if (i > 0)
				writer.write(", ");

			if (i == 0 && hasInputConversion) {
				writer.write("final " + inputDomainType.toString() + " " + param.getSimpleName().toString());
			} else {
				writer.write("final " + param.asType().toString() + " " + param.getSimpleName().toString());
			}
		}
		writer.write(") {\n");

		if (needsProvider) {
			writer.write("        return " + methodName + "(");
			for (int i = 0; i < parameters.size(); i++) {
				final VariableElement param = parameters.get(i);
				if (i > 0)
					writer.write(", ");
				writer.write(param.getSimpleName().toString());
			}
			writer.write(", ExtensionRegistry.getInstanceProvider());\n");
			writer.write("    }\n\n");

			writer.write("    /**\n");
			writer.write("     * Extension method: " + method.getSimpleName() + " (with custom provider)\n");
			writer.write("     * Original method from: " + enclosingClass.getQualifiedName() + "\n");
			writer.write("     */\n");

			writer.write("    public static " + expectedReturnType + " " + methodName + "(");

			for (int i = 0; i < parameters.size(); i++) {
				final VariableElement param = parameters.get(i);
				if (i > 0)
					writer.write(", ");

				if (i == 0 && hasInputConversion) {
					writer.write("final " + inputDomainType.toString() + " " + param.getSimpleName().toString());
				} else {
					writer.write("final " + param.asType().toString() + " " + param.getSimpleName().toString());
				}
			}
			writer.write(", final InstanceProvider provider) {\n");

			generateMethodBody(writer, method, enclosingClass, parameters, hasInputConversion, hasOutputConversion,
					inputDomainType, outputDomainType, originalReturnType, true, "provider");

			writer.write("    }\n\n");
		} else {
			generateMethodBody(writer, method, enclosingClass, parameters, hasInputConversion, hasOutputConversion,
					inputDomainType, outputDomainType, originalReturnType, false, null);
			writer.write("    }\n\n");
		}
	}

	private void generateSimpleExtensionMethod(final Writer writer, final MethodInfo methodInfo,
			final Extension extension, final String expectedReturnType) throws IOException {
		final ExecutableElement method = methodInfo.method;
		final TypeElement enclosingClass = methodInfo.enclosingClass;

		final String methodName = buildMethodName(extension);
		final List<? extends VariableElement> parameters = method.getParameters();
		final boolean isStatic = method.getModifiers().contains(Modifier.STATIC);
		final boolean needsProvider = !isStatic && needsInstanceProvider(enclosingClass);

		writer.write("    /**\n");
		writer.write("     * Extension method: " + method.getSimpleName() + "\n");
		writer.write("     * Original method from: " + enclosingClass.getQualifiedName() + "\n");
		writer.write("     * Simple wrapper without domain conversions\n");
		writer.write("     */\n");

		writer.write("    public static " + expectedReturnType + " " + methodName + "(");

		for (int i = 0; i < parameters.size(); i++) {
			final VariableElement param = parameters.get(i);
			if (i > 0)
				writer.write(", ");
			writer.write("final " + param.asType().toString() + " " + param.getSimpleName().toString());
		}

		writer.write(") {\n");

		if (needsProvider) {
			writer.write("        return " + methodName + "(");
			for (int i = 0; i < parameters.size(); i++) {
				final VariableElement param = parameters.get(i);
				if (i > 0)
					writer.write(", ");
				writer.write(param.getSimpleName().toString());
			}
			writer.write(", ExtensionRegistry.getInstanceProvider());\n");
			writer.write("    }\n\n");

			writer.write("    /**\n");
			writer.write("     * Extension method: " + method.getSimpleName() + " (with custom provider)\n");
			writer.write("     * Original method from: " + enclosingClass.getQualifiedName() + "\n");
			writer.write("     */\n");

			writer.write("    public static " + expectedReturnType + " " + methodName + "(");

			for (int i = 0; i < parameters.size(); i++) {
				final VariableElement param = parameters.get(i);
				if (i > 0)
					writer.write(", ");
				writer.write("final " + param.asType().toString() + " " + param.getSimpleName().toString());
			}

			writer.write(", final InstanceProvider provider) {\n");

			generateMethodBody(writer, method, enclosingClass, parameters, false, false, null, null,
					method.getReturnType().toString(), true, "provider");

			writer.write("    }\n\n");
		} else {
			generateMethodBody(writer, method, enclosingClass, parameters, false, false, null, null,
					method.getReturnType().toString(), false, null);
			writer.write("    }\n\n");
		}
	}

	private void generateMethodBody(final Writer writer, final ExecutableElement method,
			final TypeElement enclosingClass, final List<? extends VariableElement> parameters,
			final boolean hasInputConversion, final boolean hasOutputConversion, final TypeMirror inputDomainType,
			final TypeMirror outputDomainType, final String originalReturnType, final boolean useProvider,
			final String providerVar) throws IOException {

		final List<String> parameterNames = new ArrayList<>();

		for (int i = 0; i < parameters.size(); i++) {
			final VariableElement param = parameters.get(i);
			final String paramName = param.getSimpleName().toString();

			if (i == 0 && hasInputConversion) {
				final String sourceType = getSimpleClassName(inputDomainType.toString());
				final String targetType = getSimpleClassName(param.asType().toString());
				final String mapperName = sourceType + "To" + targetType + "Mapper";
				final String convertedName = "converted" + capitalize(paramName);

				writer.write("        final " + param.asType() + " " + convertedName + " = " + mapperName
						+ ".INSTANCE.toDto(" + paramName + ");\n");
				parameterNames.add(convertedName);
			} else {
				parameterNames.add(paramName);
			}
		}

		writer.write("        final " + originalReturnType + " result = ");

		final boolean isStatic = method.getModifiers().contains(Modifier.STATIC);

		if (isStatic) {
			writer.write(enclosingClass.getQualifiedName() + "." + method.getSimpleName() + "(");
		} else {
			final boolean classNeedsProvider = needsInstanceProvider(enclosingClass);

			if (classNeedsProvider) {
				final String providerExpression = useProvider ? providerVar : "ExtensionRegistry.getInstanceProvider()";
				writer.write(providerExpression + ".getInstance(" + enclosingClass.getSimpleName() + ".class)."
						+ method.getSimpleName() + "(");
			} else {
				writer.write("new " + enclosingClass.getQualifiedName() + "()." + method.getSimpleName() + "(");
			}
		}

		for (int i = 0; i < parameterNames.size(); i++) {
			if (i > 0)
				writer.write(", ");
			writer.write(parameterNames.get(i));
		}
		writer.write(");\n");

		if (hasOutputConversion) {
			final String sourceType = getSimpleClassName(originalReturnType);
			final String targetType = getSimpleClassName(outputDomainType.toString());
			final String mapperName = sourceType + "To" + targetType + "Mapper";
			writer.write("        return " + mapperName + ".INSTANCE.toDomain(result);\n");
		} else {
			writer.write("        return result;\n");
		}
	}

	private String buildMethodName(final Extension extension) {
		return (extension.prefix().isEmpty() ? "" : extension.prefix()) + extension.value()
				+ (extension.suffix().isEmpty() ? "" : extension.suffix());
	}

	private String capitalize(final String str) {
		if (str == null || str.isEmpty()) {
			return str;
		}
		return str.substring(0, 1).toUpperCase() + str.substring(1);
	}

	private static class MethodInfo {
		final ExecutableElement method;
		final TypeElement enclosingClass;

		MethodInfo(final ExecutableElement method, final TypeElement enclosingClass) {
			this.method = method;
			this.enclosingClass = enclosingClass;
		}
	}

	private static class MapperInfo {
		final String sourceType;
		final String targetType;
		final String packageName;
		final MapperType type;

		MapperInfo(final String sourceType, final String targetType, final String packageName, final MapperType type) {
			this.sourceType = sourceType;
			this.targetType = targetType;
			this.packageName = packageName;
			this.type = type;
		}

		@Override
		public boolean equals(final Object o) {
			if (this == o)
				return true;
			if (!(o instanceof MapperInfo))
				return false;
			final MapperInfo that = (MapperInfo) o;
			return sourceType.equals(that.sourceType) && targetType.equals(that.targetType)
					&& packageName.equals(that.packageName);
		}

		@Override
		public int hashCode() {
			return sourceType.hashCode() + targetType.hashCode() + packageName.hashCode();
		}
	}

	private enum MapperType {
		INPUT, OUTPUT
	}
}